{"version":3,"sources":["ClueList.js","GridModel.js","App.js","reportWebVitals.js","index.js"],"names":["Clues","wordList","grid","updateClue","editable","curCell","draftDirection","onClueClick","acrossClues","filter","item","direction","downClues","wordAcross","wordDown","allWordsHere","word","Container","CluesInner","DirectionClueList","title","clues","activeWord","primaryClueDirection","ClueListSection","ClueListTitle","map","idx","ClueListItem","current","x","y","onClick","ClueNum","cellNumber","ClueInput","value","clue","placeholder","onChange","e","target","ClueAnswer","Clue","styled","div","h1","input","props","span","buildGridFromWordList","gridSize","row","push","chars","Set","wordHereAcross","wordHereDown","nextCellAcross","nextCellDown","previousCellAcross","previousCellDown","xs","ys","i","length","cell","add","nextCellNumber","firstCellAcross","size","prevWordDown","firstWordDown","forEach","lastCellOfPrevWord","firstCellDown","lastCellDown","handleShortcutKeys","setDraftDirection","setDraftWord","handleKeyDown","code","preventDefault","document","body","addEventListener","removeEventListener","DraftDirectionButtons","Buttons","Button","selected","leftMost","unclickable","rightMost","Rotate","Hint","HintText","Key","val","SavedWordLists","wordLists","select","remove","duplicate","children","SavedLists","SavedListItem","TextButton","stopPropagation","url","URL","window","location","href","hash","btoa","JSON","stringify","navigator","clipboard","writeText","EditorToolbar","inputRef","draftWord","currentlySaved","saveWordList","Toolbar","ToolbarSection","WordInputWrapper","WordInput","replace","toUpperCase","validateWordInput","ref","WordInputCounter","error","empty","minWidth","fullWidth","EditableCrosswordGrid","modifiableWordItem","canCommitDraftWord","removeWord","commitWord","useState","candidatePosition","setCandidatePosition","wordHere","GridContainer","Grid","GridRow","getCharFromWord","wx","wy","modifiableIsHere","draftChar","has","GridCell","onMouseEnter","handleMouseEnter","onMouseLeave","interactable","placeable","holdingWord","modifiable","hover","hasLetter","GridCellContents","GridCellNumber","uniq","sortBy","c","GridCellChar","draft","PlayableCrosswordGrid","updateAssociatedClue","gridRef","showIncorrect","showAnswers","Array","from","gridInputs","setGridInputs","handleFocus","updateGridInputs","copyGridInputs","key","prevSibling","moveOneCell","slice","handleBackspace","dir","backwards","thisCell","targetCell","targetSibling","querySelector","focus","focusedWordHere","cellVal","inCurrentWord","GridCellInput","name","selectionStart","char","charAt","test","newVal","nextCell","nextSibling","selectionEnd","handleChange","onKeyDown","onFocus","correct","useLocalStorageState","defaultValue","saved","localStorage","getItem","parse","setValue","useEffect","setItem","EditorApp","useRef","setCurrentlySaved","draftClue","setDraftClue","setWordList","currentWordListIdx","setCurrentWordListIdx","savedWordLists","setSavedWordLists","onbeforeunload","prevSavedWordLists","selectWordList","listIdx","alert","updateWordList","func","useMemo","Body","prevList","GridClueContainer","wordItem","prevWordList","addWord","prevWordLists","PlayerApp","setShowIncorrect","setShowAnswers","setCurCell","ShowAnswersButtons","targetWord","wordInputRadius","button","App","setHash","handleHashChange","useLocationHash","atob","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.89b60f17.chunk.js","sourcesContent":["import styled from 'styled-components';\n\nexport default function Clues({\n  wordList,\n  grid,\n  updateClue,\n  editable,\n  curCell,\n  draftDirection,\n  onClueClick,\n}) {\n  let acrossClues = wordList.filter((item) => item.direction === 'x');\n  let downClues = wordList.filter((item) => item.direction === 'y');\n\n  //This only handles having one word down and one word across, which isn't all\n  // possibilities but kinda should be\n  let wordAcross = null;\n  let wordDown = null;\n  if (curCell) {\n    for (let word of curCell.allWordsHere) {\n      if (word.direction === 'x') {\n        wordAcross = word;\n      } else {\n        wordDown = word;\n      }\n    }\n  }\n\n  return (\n    <Container>\n      <CluesInner>\n        <DirectionClueList\n          title=\"Across\"\n          clues={acrossClues}\n          grid={grid}\n          updateClue={updateClue}\n          editable={editable}\n          activeWord={wordAcross}\n          primaryClueDirection={\n            wordAcross && wordAcross.direction === draftDirection\n          }\n          onClueClick={onClueClick}\n        />\n        <DirectionClueList\n          title=\"Down\"\n          clues={downClues}\n          grid={grid}\n          updateClue={updateClue}\n          editable={editable}\n          activeWord={wordDown}\n          primaryClueDirection={\n            wordDown && wordDown.direction === draftDirection\n          }\n          onClueClick={onClueClick}\n        />\n      </CluesInner>\n    </Container>\n  );\n}\n\nfunction DirectionClueList({\n  title,\n  clues,\n  grid,\n  updateClue,\n  editable,\n  activeWord,\n  primaryClueDirection,\n  onClueClick,\n}) {\n  return (\n    <ClueListSection>\n      <ClueListTitle>{title}</ClueListTitle>\n      {clues.map((item, idx) => (\n        <ClueListItem\n          key={idx}\n          current={\n            activeWord && activeWord.x === item.x && activeWord.y === item.y\n          }\n          primaryClueDirection={primaryClueDirection}\n          onClick={() => onClueClick && onClueClick(item)}\n        >\n          <ClueNum>{grid[item.y][item.x].cellNumber}</ClueNum>\n          {editable ? (\n            <>\n              <ClueInput\n                value={item.clue}\n                placeholder=\"[Clue needed]\"\n                onChange={(e) => updateClue(item, e.target.value)}\n              />\n              <ClueAnswer>{item.word}</ClueAnswer>\n            </>\n          ) : (\n            <Clue>{item.clue}</Clue>\n          )}\n        </ClueListItem>\n      ))}\n    </ClueListSection>\n  );\n}\n\nlet Container = styled.div`\n  width: 100%;\n  overflow-y: scroll;\n  min-height: 375px;\n`;\nlet CluesInner = styled.div`\n  width: 100%;\n  height: 100px;\n`;\n\nlet ClueListSection = styled.div`\n  border-top: 1px solid #eee;\n`;\nlet ClueListTitle = styled.h1`\n  font-size: 0.75em;\n  text-transform: uppercase;\n  margin: 0;\n  padding: 5px;\n`;\nlet ClueInput = styled.input`\n  padding: 5px;\n  display: block;\n  border: 1px solid #999;\n  border-radius: 3px;\n  display: inline-block;\n  font-family: inherit;\n  width: 200px;\n  ::placeholder,\n  ::-webkit-input-placeholder {\n    color: #ccc;\n  }\n`;\nlet ClueListItem = styled.div`\n  padding: 5px;\n  ${(props) =>\n    props.current\n      ? props.primaryClueDirection\n        ? 'background-color: #9ce2ff'\n        : 'background-color: #fff39f'\n      : ''}\n`;\nlet ClueNum = styled.span`\n  font-weight: bold;\n  font-size: 0.75em;\n  display: inline-block;\n  vertical-align: top;\n  margin-right: 0.25em;\n  text-align: right;\n  min-width: 1em;\n\n`;\nlet ClueAnswer = styled.span`\n  text-transform: uppercase;\n  font-size: 0.9em;\n  margin-left: 5px;\n`;\nlet Clue = styled.div`\n  font-size: 0.9em;\n  display: inline;\n`;\n","export function buildGridFromWordList(wordList, gridSize) {\n  let grid = [];\n  for (let y = 0; y < gridSize; y++) {\n    let row = [];\n    for (let x = 0; x < gridSize; x++) {\n      row.push({\n        x,\n        y,\n\n        chars: new Set(),\n        cellNumber: null,\n        wordHereAcross: null,\n        wordHereDown: null,\n        allWordsHere: new Set(),\n\n        nextCellAcross: null,\n        nextCellDown: null,\n        previousCellAcross: null,\n        previousCellDown: null,\n      });\n    }\n    grid.push(row);\n  }\n\n  for (let item of wordList) {\n    let { x, y, direction, word } = item;\n    let xs = direction === 'x' ? 1 : 0;\n    let ys = direction === 'y' ? 1 : 0;\n\n    for (let i = 0; i < word.length; i++) {\n      let row = grid[y + i * ys];\n      if (row != null && row[x + i * xs] != null) {\n        let cell = row[x + i * xs];\n        if (i === 0) {\n          if (direction === 'x') {\n            cell.wordHereAcross = item;\n          } else {\n            cell.wordHereDown = item;\n          }\n        }\n        cell.chars.add(word[i]);\n        cell.allWordsHere.add(item);\n      }\n    }\n  }\n\n  let nextCellNumber = 1;\n  let firstCellAcross = null;\n  let previousCellAcross = null;\n  for (let y = 0; y < gridSize; y++) {\n    for (let x = 0; x < gridSize; x++) {\n      let cell = grid[y][x];\n      if (cell.wordHereAcross || cell.wordHereDown) {\n        cell.cellNumber = nextCellNumber++;\n      }\n      if (cell.chars.size) {\n        if (previousCellAcross) {\n          previousCellAcross.nextCellAcross = cell;\n          cell.previousCellAcross = previousCellAcross;\n        } else {\n          firstCellAcross = cell;\n        }\n        previousCellAcross = cell;\n      }\n    }\n  }\n  if (firstCellAcross) {\n    firstCellAcross.previousCellAcross = previousCellAcross;\n    previousCellAcross.nextCellAcross = firstCellAcross;\n  }\n\n  // Set up the basics of next- and prev-cell\n  // TODO: this isn't quite right. we should go to the next cell in the word,\n  // not just the next cell down, but that means we have to handle not being in a\n  // down-word\n  let previousCellDown = null;\n  for (let x = 0; x < gridSize; x++) {\n    for (let y = 0; y < gridSize; y++) {\n      let cell = grid[y][x];\n      if (cell.chars.size) {\n        if (previousCellDown) {\n          previousCellDown.nextCellDown = cell;\n          cell.previousCellDown = previousCellDown;\n        }\n        previousCellDown = cell;\n      }\n    }\n  }\n\n  // if this is the first cell down in a word, the previous cell isn't the one\n  // right before it! it's the last cell of the previous word in the wordlist.\n  // the next cell down after the last cell in a word is also the next word\n  let prevWordDown = null;\n  let firstWordDown = null;\n  wordList.forEach((item) => {\n    if (item.direction === 'y') {\n      let cell = grid[item.y][item.x];\n      if (prevWordDown) {\n        let lastCellOfPrevWord =\n          grid[prevWordDown.y + prevWordDown.word.length - 1][prevWordDown.x];\n        cell.previousCellDown = lastCellOfPrevWord;\n\n        // last cell of the prev word links to the first cell of this word\n        lastCellOfPrevWord.nextCellDown = grid[item.y][item.x];\n      } else {\n        firstWordDown = item;\n      }\n      prevWordDown = item;\n    }\n  });\n\n  // tie up the ends:\n  if (firstWordDown) {\n    let firstCellDown = grid[firstWordDown.y][firstWordDown.x];\n    let lastCellDown =\n      grid[prevWordDown.y + prevWordDown.word.length - 1][prevWordDown.x];\n    // set the first cell's prev to wrap around to the last word\n    firstCellDown.previousCellDown = lastCellDown;\n    // set the last cell's next to wrap around to the first word\n    lastCellDown.nextCellDown = firstCellDown;\n  }\n\n  return grid;\n}\n","import { useEffect, useMemo, useState, useRef } from 'react';\nimport styled from 'styled-components';\nimport { sortBy, uniq } from 'lodash';\n\nimport ClueList from './ClueList';\nimport { buildGridFromWordList } from './GridModel';\n//import wordDictionary from './words';\n\nfunction usePreventWindowUnload(preventDefault) {\n  useEffect(() => {\n    window.onbeforeunload = null;\n\n    if (preventDefault) {\n      window.onbeforeunload = function () {\n        return true;\n      };\n    }\n  }, [preventDefault]);\n}\n\nfunction handleShortcutKeys(draftDirection, setDraftDirection, setDraftWord) {\n  let swapDraftDirection = () => {\n    setDraftDirection(draftDirection === 'x' ? 'y' : 'x');\n  };\n  function handleKeyDown(e) {\n    if (e.code === 'Enter') {\n      e.preventDefault();\n      swapDraftDirection();\n    }\n    if (setDraftWord) {\n      if (e.code === 'Escape') {\n        e.preventDefault();\n        setDraftWord('');\n      }\n    }\n  }\n  document.body.addEventListener('keydown', handleKeyDown);\n  return () => document.body.removeEventListener('keydown', handleKeyDown);\n}\n\nfunction DraftDirectionButtons({ draftDirection, setDraftDirection }) {\n  return (\n    <Buttons>\n      <Button\n        onClick={() => setDraftDirection('x')}\n        selected={draftDirection === 'x'}\n        leftMost={true}\n        unclickable={draftDirection === 'x'}\n      >\n        Across {'\\u2794'}\n      </Button>\n      <Button\n        onClick={() => setDraftDirection('y')}\n        rightMost={true}\n        selected={draftDirection === 'y'}\n        unclickable={draftDirection === 'y'}\n      >\n        Down <Rotate>{'\\u2794'}</Rotate>\n      </Button>\n      <Hint>\n        <HintText>Swap with Enter</HintText>\n        <Key val={'enter'}>{'\\u23CE'}</Key>\n      </Hint>\n    </Buttons>\n  );\n}\n\nfunction SavedWordLists({\n  selected,\n  wordLists,\n  select,\n  remove,\n  duplicate,\n  children,\n}) {\n  return (\n    <SavedLists>\n      {wordLists.map((wordList, idx) => {\n        return (\n          <SavedListItem\n            key={idx}\n            onClick={() => {\n              if (selected !== idx) {\n                select(idx);\n              }\n            }}\n            selected={selected === idx}\n          >\n            Crossword #{idx} ({wordList.length} word\n            {wordList.length === 1 ? '' : 's'})\n            {selected === idx && (\n              <>\n                <TextButton\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    let url = new URL(window.location.href);\n                    url.hash = `#${btoa(JSON.stringify(wordList))}`;\n                    navigator.clipboard.writeText(url);\n                  }}\n                >\n                  (Copy URL)\n                </TextButton>\n                <TextButton\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    remove(idx);\n                  }}\n                >\n                  (Delete)\n                </TextButton>\n                <TextButton\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    duplicate(idx);\n                  }}\n                >\n                  (Duplicate)\n                </TextButton>\n              </>\n            )}\n          </SavedListItem>\n        );\n      })}\n      {children}\n    </SavedLists>\n  );\n}\n\nfunction EditorToolbar({\n  inputRef,\n  gridSize,\n  draftWord,\n  setDraftWord,\n  draftDirection,\n  setDraftDirection,\n  currentlySaved,\n  saveWordList,\n}) {\n  let validateWordInput = (e) => {\n    e.target.value = e.target.value\n      .replace(/[^\\w?]/g, '')\n      .replace(/[_]/g, '')\n      .toUpperCase();\n    setDraftWord(e.target.value);\n  };\n\n  return (\n    <Toolbar>\n      <ToolbarSection>\n        <WordInputWrapper>\n          <WordInput\n            value={draftWord}\n            onChange={(e) => validateWordInput(e)}\n            placeholder={'Enter a new word...'}\n            ref={inputRef}\n          />\n          <WordInputCounter\n            error={draftWord.length > gridSize}\n            empty={draftWord.length === 0}\n          >\n            {draftWord.length}\n          </WordInputCounter>\n        </WordInputWrapper>\n        <Hint>\n          <HintText>Clear with Escape</HintText>\n          <Key>ESC</Key>\n        </Hint>\n      </ToolbarSection>\n      <DraftDirectionButtons\n        setDraftDirection={setDraftDirection}\n        draftDirection={draftDirection}\n      />\n      <Buttons minWidth={'100px'}>\n        <Button\n          onClick={saveWordList}\n          fullWidth={true}\n          unclickable={currentlySaved}\n        >\n          Save\n        </Button>\n        <Hint>\n          <HintText>{currentlySaved ? '✔ Saved' : '✖ Unsaved'}</HintText>\n        </Hint>\n      </Buttons>\n    </Toolbar>\n  );\n}\n\nfunction EditableCrosswordGrid({\n  draftWord,\n  draftDirection,\n  removeWord,\n  commitWord,\n  grid,\n}) {\n  let [candidatePosition, setCandidatePosition] = useState(null);\n\n  // Is there a word starting here? (Preferably, one in the right direction.)\n  let wordHere = null;\n  if (candidatePosition) {\n    let { x, y } = candidatePosition;\n    let wordHereAcross = grid[y][x].wordHereAcross;\n    let wordHereDown = grid[y][x].wordHereDown;\n    wordHere =\n      draftDirection === 'x'\n        ? wordHereAcross ?? wordHereDown\n        : wordHereDown ?? wordHereAcross;\n  }\n\n  let modifiableWordItem, canCommitDraftWord;\n  if (draftWord) {\n    // Making a new word. We can't commit if there's already a word here in the\n    // same direction.\n    modifiableWordItem = null;\n    canCommitDraftWord = !wordHere || wordHere.direction !== draftDirection;\n  } else {\n    // If we're hovering over a word, we can edit it.\n    modifiableWordItem = wordHere;\n    canCommitDraftWord = false;\n  }\n\n  let handleMouseEnter = (x, y) => {\n    setCandidatePosition({ x, y });\n  };\n  let handleMouseLeave = () => {\n    setCandidatePosition(null);\n  };\n  return (\n    <GridContainer>\n      <Grid>\n        {grid.map((row, y) => {\n          return (\n            <GridRow key={y}>\n              {row.map((cell, x) => {\n                let { chars, allWordsHere } = cell;\n\n                function getCharFromWord({ word, direction, x: wx, y: wy }) {\n                  let chars = [...word];\n                  if (direction === 'x' && wy === y) {\n                    return chars[x - wx];\n                  } else if (direction === 'y' && wx === x) {\n                    return chars[y - wy];\n                  }\n                }\n\n                let modifiableIsHere = false;\n                let draftChar = '';\n                if (allWordsHere.has(modifiableWordItem)) {\n                  modifiableIsHere = true;\n                  draftChar = getCharFromWord(modifiableWordItem);\n                }\n                if (candidatePosition) {\n                  draftChar =\n                    getCharFromWord({\n                      word: draftWord,\n                      direction: draftDirection,\n                      x: candidatePosition.x,\n                      y: candidatePosition.y,\n                    }) || '';\n                }\n\n                return (\n                  <GridCell\n                    key={x}\n                    onMouseEnter={() => handleMouseEnter(x, y)}\n                    onMouseLeave={() => handleMouseLeave(x, y)}\n                    interactable={canCommitDraftWord || modifiableIsHere}\n                    placeable={draftWord.length > 0 && canCommitDraftWord}\n                    holdingWord={draftWord.length > 0}\n                    modifiable={modifiableIsHere}\n                    hover={modifiableIsHere && !draftWord.length}\n                    hasLetter={chars.size || draftChar}\n                    onClick={() => {\n                      if (modifiableWordItem) {\n                        removeWord(modifiableWordItem);\n                      } else if (canCommitDraftWord) {\n                        commitWord(x, y);\n                      }\n                    }}\n                  >\n                    <GridCellContents>\n                      <GridCellNumber>{grid[y][x].cellNumber}</GridCellNumber>\n                      {uniq([...sortBy([...chars]), ...draftChar]).map((c) => {\n                        return (\n                          <GridCellChar\n                            error={\n                              chars.size > 1 ||\n                              (chars.size > 0 &&\n                                c === draftChar &&\n                                !chars.has(draftChar))\n                            }\n                            draft={c === draftChar}\n                            key={c}\n                          >\n                            {c}\n                          </GridCellChar>\n                        );\n                      })}\n                    </GridCellContents>\n                  </GridCell>\n                );\n              })}\n            </GridRow>\n          );\n        })}\n      </Grid>\n    </GridContainer>\n  );\n}\n\nfunction PlayableCrosswordGrid({\n  draftDirection,\n  grid,\n  updateAssociatedClue,\n  curCell,\n  gridRef,\n  showIncorrect,\n  showAnswers,\n}) {\n  let [gridInputs, setGridInputs] = useState(\n    Array.from({ length: 20 }, () => Array.from({ length: 20 }, () => ''))\n  );\n  let handleUnFocus = () => {\n    updateAssociatedClue(null);\n  };\n  let handleFocus = (x, y, cell) => {\n    handleUnFocus();\n    if (cell) {\n      updateAssociatedClue(cell);\n    }\n  };\n\n  let updateGridInputs = (x, y, val) => {\n    let copyGridInputs = [...gridInputs];\n    copyGridInputs[x][y] = val;\n    setGridInputs(copyGridInputs);\n  };\n\n  // get the FIRST word found for each direction. There can technically be more,\n  // but that's not a valid crossword in the traditional sense.\n  let wordHere = null;\n  if (curCell) {\n    for (const e of curCell.allWordsHere) {\n      if (e.direction === draftDirection) {\n        wordHere = e;\n        break;\n      }\n    }\n  }\n\n  function handleChange(e, x, y) {\n    const input = e.target;\n    const { value, selectionStart } = input;\n\n    // TODO: better unicode support\n    let char = value.charAt(selectionStart - 1);\n    if (/[\\w]/.test(char)) {\n      let newVal = char.toUpperCase();\n      e.target.value = newVal;\n      updateGridInputs(x, y, newVal);\n\n      // Get the next input field\n      let thisCell = grid[y][x];\n      let nextCell =\n        draftDirection === 'x'\n          ? thisCell.nextCellAcross\n          : thisCell.nextCellDown;\n      let nextSibling = gridRef.current.querySelector(\n        `[name=\"cellinput-${nextCell.x}-${nextCell.y}\"]`\n      );\n\n      // If found, focus the next field\n      if (nextSibling !== null) {\n        nextSibling.focus();\n        nextSibling.selectionStart = nextSibling.selectionEnd = 0;\n      }\n    } else {\n      e.target.value = '';\n      updateGridInputs(x, y, '');\n    }\n  }\n\n  function handleKeyDown(e, x, y) {\n    if (e.key === 'Backspace') {\n      handleBackspace(e, x, y);\n    }\n    if (e.key === 'ArrowLeft') {\n      moveOneCell(x, y, 'x', true);\n    }\n    if (e.key === 'ArrowRight') {\n      moveOneCell(x, y, 'x', false);\n    }\n    if (e.key === 'ArrowUp') {\n      moveOneCell(x, y, 'y', true);\n    }\n    if (e.key === 'ArrowDown') {\n      moveOneCell(x, y, 'y', false);\n    }\n  }\n\n  function moveOneCell(x, y, dir, backwards) {\n    let thisCell = grid[y][x];\n    let targetCell = null;\n\n    if (backwards) {\n      targetCell =\n        dir === 'x' ? thisCell.previousCellAcross : thisCell.previousCellDown;\n    } else {\n      targetCell =\n        dir === 'x' ? thisCell.nextCellAcross : thisCell.nextCellDown;\n    }\n    let targetSibling = gridRef.current.querySelector(\n      `[name=\"cellinput-${targetCell.x}-${targetCell.y}\"]`\n    );\n\n    if (targetSibling !== null) {\n      targetSibling.focus();\n    }\n    return targetSibling;\n  }\n\n  function handleBackspace(e, x, y) {\n    const { value } = e.target;\n    if (value.length !== 0) {\n      // Allow normal backspace\n      e.target.value = '';\n      updateGridInputs(x, y, '');\n      return;\n    }\n\n    e.preventDefault();\n\n    let prevSibling = moveOneCell(x, y, draftDirection, true);\n    if (prevSibling) {\n      prevSibling.value = prevSibling.value.slice(0, -1);\n    }\n  }\n\n  return (\n    <GridContainer>\n      <Grid ref={gridRef}>\n        {grid.map((row, y) => (\n          <GridRow key={y}>\n            {row.map((cell, x) => {\n              let hasLetter = cell.chars.size > 0;\n              let focusedWordHere = false;\n              if (cell.allWordsHere.has(wordHere)) {\n                focusedWordHere = true;\n              }\n              let cellVal = '';\n              cell.chars.forEach((c) => (cellVal += c));\n              return (\n                <GridCell\n                  key={x}\n                  hasLetter={hasLetter}\n                  inCurrentWord={focusedWordHere}\n                >\n                  <GridCellContents>\n                    <GridCellNumber>{grid[y][x].cellNumber}</GridCellNumber>\n                    {hasLetter > 0 && (\n                      <GridCellInput\n                        value={showAnswers ? cellVal : gridInputs[x][y]}\n                        name={`cellinput-${x}-${y}`}\n                        onChange={(e) => handleChange(e, x, y)}\n                        onKeyDown={(e) => handleKeyDown(e, x, y)}\n                        onFocus={() => handleFocus(x, y, cell)}\n                        showAnswers={showIncorrect || showAnswers}\n                        correct={gridInputs[x][y] === cellVal}\n                        empty={gridInputs[x][y] === ''}\n                      />\n                    )}\n                  </GridCellContents>\n                </GridCell>\n              );\n            })}\n          </GridRow>\n        ))}\n      </Grid>\n    </GridContainer>\n  );\n}\n\nfunction useLocalStorageState(key, defaultValue) {\n  let [value, setValue] = useState(() => {\n    const saved = localStorage.getItem(key);\n    const initialValue = JSON.parse(saved);\n    return initialValue || defaultValue;\n  });\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n  return [value, setValue];\n}\n\nfunction EditorApp() {\n  let inputRef = useRef(null);\n\n  let [currentlySaved, setCurrentlySaved] = useState(true);\n\n  let [draftDirection, setDraftDirection] = useState('x');\n  let [draftWord, setDraftWord] = useState('');\n  let [draftClue, setDraftClue] = useState('');\n\n  let [wordList, setWordList] = useLocalStorageState('wordList', []);\n\n  // TODO: change wordlists to an object where the keys are unique timestamps etc,\n  // instead of using an array, so you can have titles for each crossword and links\n  // to them, etc\n  let [currentWordListIdx, setCurrentWordListIdx] = useLocalStorageState(\n    'currentWordListIdx',\n    0\n  );\n  let [savedWordLists, setSavedWordLists] = useLocalStorageState(\n    'savedWordLists',\n    []\n  );\n\n  usePreventWindowUnload(!currentlySaved);\n\n  let saveWordList = () => {\n    setCurrentlySaved(true);\n    setSavedWordLists((prevSavedWordLists) => {\n      if (prevSavedWordLists[currentWordListIdx]) {\n        return prevSavedWordLists.map((prevList, idx) => {\n          return idx === currentWordListIdx ? wordList : prevList;\n        });\n      } else {\n        return [...prevSavedWordLists, []];\n      }\n    });\n  };\n\n  useEffect(() => {\n    return handleShortcutKeys(draftDirection, setDraftDirection, setDraftWord);\n  }, [draftDirection]);\n\n  useEffect(() => {\n    if (!savedWordLists[currentWordListIdx]) {\n      setCurrentlySaved(true);\n      setSavedWordLists((prevSavedWordLists) => {\n        return [...prevSavedWordLists, []];\n      });\n      setWordList([]);\n    } else {\n      setWordList(savedWordLists[currentWordListIdx]);\n    }\n  }, [savedWordLists, currentWordListIdx, setWordList, setSavedWordLists]);\n\n  let updateClue = (wordItem, clue) => {\n    updateWordList((prevWordList) => {\n      return sortBy(\n        prevWordList.map((item) =>\n          item.word === wordItem.word &&\n          item.x === wordItem.x &&\n          item.y === wordItem.y\n            ? { ...item, clue }\n            : item\n        ),\n        (item) => item.y,\n        (item) => item.x\n      );\n    });\n  };\n\n  let addWord = (x, y, direction, word, clue) => {\n    updateWordList((prevWordList) => {\n      return sortBy(\n        [...prevWordList, { x, y, direction, word, clue }],\n        (item) => item.y,\n        (item) => item.x\n      );\n    });\n  };\n\n  let newWordList = () => {\n    selectWordList(savedWordLists.length);\n  };\n\n  let selectWordList = (listIdx) => {\n    if (!currentlySaved) {\n      alert('You have unsaved changes');\n    } else {\n      setCurrentWordListIdx(listIdx);\n    }\n  };\n\n  let removeWordList = (idx) => {\n    if (currentWordListIdx === idx) {\n      // Remove the current wordlist\n      setCurrentWordListIdx(0);\n      setSavedWordLists((prevWordLists) => {\n        return [\n          ...prevWordLists.slice(0, idx),\n          ...prevWordLists.slice(idx + 1),\n        ];\n      });\n    } else {\n      if (!currentlySaved) {\n        alert('Please save before making changes');\n      }\n      // BUG: removing other wordlists will erase your unsaved data\n    }\n  };\n\n  let duplicateWordList = (idx) => {\n    if (currentWordListIdx === idx) {\n      // Remove the current wordlist\n      setCurrentWordListIdx(0);\n      setSavedWordLists((prevWordLists) => {\n        return [\n          ...prevWordLists.slice(0, idx),\n          ...prevWordLists.slice(idx, idx + 1),\n          ...prevWordLists.slice(idx),\n        ];\n      });\n    } else {\n      if (!currentlySaved) {\n        alert('Please save before making changes');\n      }\n    }\n  };\n\n  let updateWordList = (func) => {\n    setCurrentlySaved(false);\n    setWordList(func);\n  };\n\n  let gridSize = 15;\n  let grid = useMemo(\n    () => buildGridFromWordList(wordList, gridSize),\n    [wordList, gridSize]\n  );\n\n  let commitWord = (x, y) => {\n    addWord(x, y, draftDirection, draftWord, draftClue);\n    setDraftWord('');\n    setDraftClue('');\n    inputRef.current.focus();\n  };\n  let removeWord = (wordItem) => {\n    updateWordList(wordList.filter((item) => item !== wordItem));\n    setDraftWord(wordItem.word);\n    setDraftClue(wordItem.clue);\n    setDraftDirection(wordItem.direction);\n  };\n  /*return <div>\n    {wordDictionary.sort((a, b) => {return a.length - b.length}).map(w => {\n      return <div key={w}>\"{w}\",</div>\n    })}\n  </div>;*/\n\n  return (\n    <Body>\n      <EditorToolbar\n        inputRef={inputRef}\n        gridSize={gridSize}\n        draftWord={draftWord}\n        setDraftWord={setDraftWord}\n        draftDirection={draftDirection}\n        setDraftDirection={setDraftDirection}\n        currentlySaved={currentlySaved}\n        saveWordList={saveWordList}\n      />\n      <GridClueContainer>\n        <EditableCrosswordGrid\n          draftWord={draftWord}\n          draftDirection={draftDirection}\n          removeWord={removeWord}\n          commitWord={commitWord}\n          grid={grid}\n        />\n        <ClueList\n          wordList={wordList}\n          grid={grid}\n          updateClue={updateClue}\n          editable={true}\n        />\n      </GridClueContainer>\n      <SavedWordLists\n        wordLists={savedWordLists}\n        selected={currentWordListIdx}\n        saved={currentlySaved}\n        select={selectWordList}\n        remove={removeWordList}\n        duplicate={duplicateWordList}\n      >\n        <Button onClick={newWordList}>New Crossword</Button>\n      </SavedWordLists>\n    </Body>\n  );\n}\n\nfunction PlayerApp({ wordList, gridSize }) {\n  let [draftDirection, setDraftDirection] = useState('x');\n  let [showIncorrect, setShowIncorrect] = useState(false);\n  let [showAnswers, setShowAnswers] = useState(false);\n  let [curCell, setCurCell] = useState(null);\n  let gridRef = useRef(null);\n  let grid = useMemo(\n    () => buildGridFromWordList(wordList, gridSize),\n    [wordList, gridSize]\n  );\n  let updateAssociatedClue = (cell) => {\n    setCurCell(cell);\n  };\n\n  useEffect(() => {\n    return handleShortcutKeys(draftDirection, setDraftDirection, null);\n  }, [draftDirection]);\n\n  let onClueClick = (word) => {\n    let targetWord = gridRef.current.querySelector(\n      `[name=\"cellinput-${word.x}-${word.y}\"]`\n    );\n\n    if (targetWord !== null) {\n      targetWord.focus();\n      setDraftDirection(word.direction);\n    }\n  };\n\n  return (\n    <Body>\n      <Toolbar>\n        <DraftDirectionButtons\n          setDraftDirection={setDraftDirection}\n          draftDirection={draftDirection}\n        />\n        <Buttons>\n          <ShowAnswersButtons>\n            <Button\n              selected={showIncorrect}\n              onClick={() => {\n                setShowIncorrect(!showIncorrect);\n              }}\n            >\n              Show Incorrect\n            </Button>\n            <Button\n              selected={showAnswers}\n              onClick={() => {\n                setShowAnswers(!showAnswers);\n              }}\n            >\n              Show Answers\n            </Button>\n          </ShowAnswersButtons>\n        </Buttons>\n      </Toolbar>\n\n      <GridClueContainer>\n        <PlayableCrosswordGrid\n          draftDirection={draftDirection}\n          grid={grid}\n          updateAssociatedClue={updateAssociatedClue}\n          curCell={curCell}\n          gridRef={gridRef}\n          showIncorrect={showIncorrect}\n          showAnswers={showAnswers}\n        />\n        <ClueList\n          wordList={wordList}\n          grid={grid}\n          editable={false}\n          curCell={curCell}\n          draftDirection={draftDirection}\n          onClueClick={onClueClick}\n        />\n      </GridClueContainer>\n    </Body>\n  );\n}\n\nfunction useLocationHash() {\n  let [hash, setHash] = useState(window.location.hash);\n  useEffect(() => {\n    function handleHashChange() {\n      setHash(window.location.hash);\n    }\n    window.addEventListener('hashchange', handleHashChange);\n    return () => {\n      window.removeEventListener('hashchange', handleHashChange);\n    };\n  }, []);\n  return hash;\n}\n\nfunction App() {\n  let hash = useLocationHash();\n\n  if (hash) {\n    const wordList = JSON.parse(atob(hash.slice(1)));\n    let gridSize = 15;\n    return <PlayerApp wordList={wordList} gridSize={gridSize} />;\n  } else {\n    return <EditorApp />;\n  }\n}\n\nlet Body = styled.div`\n  font-size: 16px;\n`;\n\nlet Toolbar = styled.div`\n  display: flex;\n  padding: 5px;\n`;\nlet ToolbarSection = styled.div`\n  display: flex;\n  flex-direction: column;\n  text-align: center;\n  flex-grow: 1;\n`;\nlet WordInputWrapper = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n`;\nlet wordInputRadius = '3px';\nlet WordInputCounter = styled.div`\n  font-weight: bold;\n  padding: 4px;\n  width: 2em;\n  background: #eee;\n  border: 1px solid #999;\n  border-radius: 0 ${wordInputRadius} ${wordInputRadius} 0;\n  border-left: none;\n  color: ${(props) => (props.error ? 'red' : props.empty ? '#ddd' : '#555')};\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`;\nlet WordInput = styled.input`\n  flex-grow: 1;\n  padding: 6px 7px;\n  letter-spacing: 3px;\n  border-radius: ${wordInputRadius} 0 0 ${wordInputRadius};\n  border: 1px solid #999;\n  font-family: inherit;\n  z-index: 2;\n  ::placeholder,\n  ::-webkit-input-placeholder {\n    color: #ccc;\n    letter-spacing: initial;\n  }\n  :focus {\n    border: 1px solid #1a8fbf;\n    box-shadow: 0 0 1px 2px #1a8fbf;\n    outline: none;\n  }\n`;\n\nlet Buttons = styled.div`\n  text-align: center;\n  margin-left: 10px;\n  min-width: ${(props) => props.minWidth || 'none'};\n`;\nlet ShowAnswersButtons = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  & > button {\n    margin-bottom: 5px;\n  }\n`;\nlet Rotate = styled.span`\n  transform: rotate(90deg);\n  display: inline-block;\n`;\nlet Button = styled.button`\n  background: ${(props) =>\n    props.selected ? '#4cc7f9' : props.unclickable ? '#ccc' : '#eee'};\n  color: ${(props) =>\n    props.selected ? 'black' : props.unclickable ? '#888' : 'black'};\n  border: 1px solid ${(props) => (props.selected ? '#1a8fbf' : '#ccc')};\n  width: ${(props) => (props.fullWidth ? '100%' : 'inherit')};\n  border-radius: ${(props) =>\n    props.rightMost\n      ? '0 10px 10px 0'\n      : props.leftMost\n      ? '10px 0 0 10px'\n      : '10px'};\n  padding: 7px;\n  cursor: ${(props) => (props.unclickable ? 'default' : 'pointer')};\n  :hover {\n    background: ${(props) =>\n      props.selected ? '#4cc7f9' : props.unclickable ? '#ccc' : '#ddd'};\n  }\n`;\n\nlet Hint = styled.div`\n  font-color: #999;\n  padding: 5px;\n  font-size: 0.5em;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`;\nlet HintText = styled.span`\n  margin-right: 5px;\n`;\nlet Key = styled.span`\n  font-color: #999;\n  padding: 3px 5px 10px ${(props) => (props.val === 'enter' ? '10px' : '5px')};\n  display: inline-block;\n  background: #eee;\n\n  height: 0.5em;\n  border: 1px solid #999;\n  font-size: 1em;\n  border-radius: 3px;\n  vertical-align: middle;\n`;\n\nlet GridClueContainer = styled.div`\n  display: flex;\n  align-items: stretch;\n  @media (max-width: 680px) {\n    flex-direction: column;\n  }\n`;\n\nlet GridContainer = styled.div`\n  display: flex;\n  justify-content: center;\n`;\nlet Grid = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 1px;\n  background: #7b7a87;\n  border: 1px solid #7b7a87;\n`;\n\nlet GridRow = styled.div`\n  display: flex;\n  flex-direction: row;\n  gap: 1px;\n`;\n\nlet GridCell = styled.div`\n  cursor: ${(props) =>\n    props.holdingWord && !props.placeable\n      ? 'not-allowed'\n      : props.holdingWord\n      ? 'grabbing'\n      : props.interactable\n      ? 'grab'\n      : 'default'};\n  background: ${(props) =>\n    props.inCurrentWord\n      ? '#b8ebff'\n      : props.modifiable && props.hover\n      ? '#eee'\n      : props.hasLetter\n      ? '#fff'\n      : 'black'};\n`;\n\nlet GridCellContents = styled.div`\n  width: 1.5em;\n  height: 1.5em;\n  text-align: center;\n  position: relative;\n  display: flex;\n  align-items: center;\n  box-sizing: border-box;\n  justify-content: center;\n  text-transform: uppercase;\n`;\n\nlet GridCellChar = styled.div`\n  color: ${(props) => (props.error ? 'red' : null)};\n  font-weight: ${(props) => (props.draft ? 'bold' : '')};\n  padding-top: 5px;\n  width: 100%;\n  box-sizing: border-box;\n`;\nlet GridCellInput = styled.input`\n  width: 100%;\n  position: absolute;\n  background: transparent;\n  text-align: center;\n  box-sizing: border-box;\n  font-family: inherit;\n  top: 0;\n  left: 0;\n  border: 0px;\n  font-size: 1em;\n  padding: 0;\n  padding-top: 6px;\n  caret-color: transparent;\n  color: ${(props) =>\n    props.showAnswers\n      ? props.empty\n        ? '#999'\n        : props.correct\n        ? 'blue'\n        : 'red'\n      : '#333'};\n\n  :focus {\n    outline: none;\n    background: #4cc7f9;\n  }\n`;\n\nlet GridCellNumber = styled.span`\n  position: absolute;\n  top: 0px;\n  left: 1px;\n  font-size: 0.5em;\n  z-index: 2;\n`;\n\nlet SavedLists = styled.div`\n  padding: 10px;\n`;\nlet SavedListItem = styled.div`\n  padding: 10px;\n  background: ${(props) => (props.selected ? '#4cc7f9' : '#eee')};\n  color: ${(props) => (props.selected ? 'black' : 'black')};\n  border: 1px solid ${(props) => (props.selected ? '#1a8fbf' : '#eee')};\n  cursor: ${(props) => (props.selected ? 'default' : 'pointer')};\n  :hover {\n    background: ${(props) => (props.selected ? '#4cc7f9' : '#ddd')};\n  }\n`;\nlet TextButton = styled.button`\n  background: none;\n  border: none;\n  color: #1a8fbf;\n  text-decoration: underline;\n  cursor: pointer;\n  padding: 0px 10px;\n  :hover {\n    color: #fff;\n  }\n`;\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}