{"version":3,"sources":["ClueList.js","GridModel.js","App.js","reportWebVitals.js","index.js"],"names":["Clues","wordList","grid","updateClue","editable","acrossClues","filter","item","direction","downClues","Container","CluesInner","DirectionClueList","title","clues","ClueListSection","ClueListTitle","map","idx","ClueListItem","ClueNum","y","x","cellNumber","ClueAnswer","word","ClueInput","value","clue","placeholder","onChange","e","target","Clue","styled","div","h1","input","span","buildGridFromWordList","gridSize","row","push","chars","Set","wordHereAcross","wordHereDown","allWordsHere","nextCellAcross","nextCellDown","previousCellAcross","previousCellDown","xs","ys","i","length","cell","add","nextCellNumber","firstCellAcross","size","firstCellDown","DraftDirectionButtons","draftDirection","setDraftDirection","Buttons","Button","onClick","selected","leftMost","unclickable","rightMost","Rotate","Hint","HintText","Key","val","SavedWordLists","wordLists","select","remove","duplicate","children","SavedLists","SavedListItem","TextButton","stopPropagation","url","URL","window","location","href","hash","btoa","JSON","stringify","navigator","clipboard","writeText","EditorToolbar","inputRef","draftWord","setDraftWord","currentlySaved","saveWordList","Toolbar","ToolbarSection","WordInputWrapper","WordInput","replace","toUpperCase","validateWordInput","ref","WordInputCounter","error","empty","minWidth","fullWidth","EditableCrosswordGrid","modifiableWordItem","canCommitDraftWord","removeWord","commitWord","useState","candidatePosition","setCandidatePosition","wordHere","Grid","GridRow","getCharFromWord","wx","wy","modifiableIsHere","draftChar","has","GridCell","onMouseEnter","handleMouseEnter","onMouseLeave","interactable","placeable","holdingWord","modifiable","hover","hasLetter","GridCellContents","GridCellNumber","uniq","sortBy","c","GridCellChar","draft","PlayableCrosswordGrid","gridRef","useRef","handleKeyDown","key","preventDefault","prevSibling","moveOneCell","slice","handleBackspace","dir","backwards","thisCell","targetCell","targetSibling","current","querySelector","focus","GridCellInput","name","selectionStart","char","charAt","test","nextCell","nextSibling","selectionEnd","handleChange","onKeyDown","useLocalStorageState","defaultValue","saved","localStorage","getItem","parse","setValue","useEffect","setItem","EditorApp","setCurrentlySaved","draftClue","setDraftClue","setWordList","currentWordListIdx","setCurrentWordListIdx","savedWordLists","setSavedWordLists","onbeforeunload","code","document","body","addEventListener","removeEventListener","prevSavedWordLists","selectWordList","listIdx","alert","updateWordList","func","useMemo","Body","prevList","GridClueContainer","wordItem","prevWordList","addWord","prevWordLists","PlayerApp","wordInputRadius","props","button","App","setHash","handleHashChange","useLocationHash","atob","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.a9a4968c.chunk.js","sourcesContent":["import styled from 'styled-components';\n\nexport default function Clues({ wordList, grid, updateClue, editable }) {\n  let acrossClues = wordList.filter((item) => item.direction === 'x');\n  let downClues = wordList.filter((item) => item.direction === 'y');\n\n  return (\n    <Container>\n      <CluesInner>\n        <DirectionClueList\n          title=\"Across\"\n          clues={acrossClues}\n          grid={grid}\n          updateClue={updateClue}\n          editable={editable}\n        />\n        <DirectionClueList\n          title=\"Down\"\n          clues={downClues}\n          grid={grid}\n          updateClue={updateClue}\n          editable={editable}\n        />\n      </CluesInner>\n    </Container>\n  );\n}\n\nfunction DirectionClueList({ title, clues, grid, updateClue, editable }) {\n  return (\n    <ClueListSection>\n      <ClueListTitle>{title}</ClueListTitle>\n      {clues.map((item, idx) => (\n        <ClueListItem key={idx}>\n          <ClueNum>{grid[item.y][item.x].cellNumber}</ClueNum>\n          {editable ? (\n            <>\n              <ClueAnswer>{item.word}</ClueAnswer>\n              <ClueInput\n                value={item.clue}\n                placeholder=\"[Clue needed]\"\n                onChange={(e) => updateClue(item, e.target.value)}\n              />\n            </>\n          ) : (\n            <Clue>{item.clue}</Clue>\n          )}\n        </ClueListItem>\n      ))}\n    </ClueListSection>\n  );\n}\n\nlet Container = styled.div`\n  width: 100%;\n  overflow-y: scroll;\n`;\nlet CluesInner = styled.div`\n  width: 100%;\n  height: 100px;\n`;\n\nlet ClueListSection = styled.div`\n  padding: 5px;\n  border-top: 1px solid #eee;\n`;\nlet ClueListTitle = styled.h1`\n  font-size: 0.75em;\n  text-transform: uppercase;\n  margin: 0;\n  margin-bottom: 5px;\n`;\nlet ClueInput = styled.input`\n  padding: 5px;\n  margin: 2px;\n  display: block;\n  ::placeholder,\n  ::-webkit-input-placeholder {\n    color: #ccc;\n  }\n`;\nlet ClueListItem = styled.div`\n  margin-bottom: 10px;\n`;\nlet ClueNum = styled.span`\n  font-weight: bold;\n  font-size: 0.75em;\n  display: inline-block;\n  vertical-align: top;\n  margin-right: 0.25em;\n`;\nlet ClueAnswer = styled.span`\n  text-transform: uppercase;\n  font-size: 0.9em;\n`;\nlet Clue = styled.div`\n  font-size: 0.9em;\n`;\n","export function buildGridFromWordList(wordList, gridSize) {\n  let grid = [];\n  for (let y = 0; y < gridSize; y++) {\n    let row = [];\n    for (let x = 0; x < gridSize; x++) {\n      row.push({\n        x,\n        y,\n\n        chars: new Set(),\n        cellNumber: null,\n        wordHereAcross: null,\n        wordHereDown: null,\n        allWordsHere: new Set(),\n\n        nextCellAcross: null,\n        nextCellDown: null,\n        previousCellAcross: null,\n        previousCellDown: null,\n      });\n    }\n    grid.push(row);\n  }\n\n  for (let item of wordList) {\n    let { x, y, direction, word } = item;\n    let xs = direction === 'x' ? 1 : 0;\n    let ys = direction === 'y' ? 1 : 0;\n\n    for (let i = 0; i < word.length; i++) {\n      let row = grid[y + i * ys];\n      if (row != null && row[x + i * xs] != null) {\n        let cell = row[x + i * xs];\n        if (i === 0) {\n          if (direction === 'x') {\n            cell.wordHereAcross = item;\n          } else {\n            cell.wordHereDown = item;\n          }\n        }\n        cell.chars.add(word[i]);\n        cell.allWordsHere.add(item);\n      }\n    }\n  }\n\n  let nextCellNumber = 1;\n  let firstCellAcross = null;\n  let previousCellAcross = null;\n  for (let y = 0; y < gridSize; y++) {\n    for (let x = 0; x < gridSize; x++) {\n      let cell = grid[y][x];\n      if (cell.wordHereAcross || cell.wordHereDown) {\n        cell.cellNumber = nextCellNumber++;\n      }\n      if (cell.chars.size) {\n        if (previousCellAcross) {\n          previousCellAcross.nextCellAcross = cell;\n          cell.previousCellAcross = previousCellAcross;\n        } else {\n          firstCellAcross = cell;\n        }\n        previousCellAcross = cell;\n      }\n    }\n  }\n  if (firstCellAcross) {\n    firstCellAcross.previousCellAcross = previousCellAcross;\n    previousCellAcross.nextCellAcross = firstCellAcross;\n  }\n\n  let firstCellDown = null;\n  let previousCellDown = null;\n  for (let x = 0; x < gridSize; x++) {\n    for (let y = 0; y < gridSize; y++) {\n      let cell = grid[y][x];\n      if (cell.chars.size) {\n        if (previousCellDown) {\n          previousCellDown.nextCellDown = cell;\n          cell.previousCellDown = previousCellDown;\n        } else {\n          firstCellDown = cell;\n        }\n        previousCellDown = cell;\n      }\n    }\n  }\n  if (firstCellDown) {\n    firstCellDown.previousCellDown = previousCellDown;\n    previousCellDown.nextCellDown = firstCellDown;\n  }\n\n  return grid;\n}\n","import { useEffect, useMemo, useState, useRef } from 'react';\nimport styled from 'styled-components';\nimport { sortBy, uniq } from 'lodash';\n\nimport ClueList from './ClueList';\nimport { buildGridFromWordList } from './GridModel';\n\nfunction usePreventWindowUnload(preventDefault) {\n  useEffect(() => {\n    window.onbeforeunload = null;\n\n    if (preventDefault) {\n      window.onbeforeunload = function () {\n        return true;\n      };\n    }\n  }, [preventDefault]);\n}\n\nfunction DraftDirectionButtons({ draftDirection, setDraftDirection }) {\n  return (\n    <Buttons>\n      <Button\n        onClick={() => setDraftDirection('x')}\n        selected={draftDirection === 'x'}\n        leftMost={true}\n        unclickable={draftDirection === 'x'}\n      >\n        Across {'\\u2794'}\n      </Button>\n      <Button\n        onClick={() => setDraftDirection('y')}\n        rightMost={true}\n        selected={draftDirection === 'y'}\n        unclickable={draftDirection === 'y'}\n      >\n        Down <Rotate>{'\\u2794'}</Rotate>\n      </Button>\n      <Hint>\n        <HintText>Swap with Enter</HintText>\n        <Key val={'enter'}>{'\\u23CE'}</Key>\n      </Hint>\n    </Buttons>\n  );\n}\n\nfunction SavedWordLists({ selected, wordLists, select, remove, duplicate, children }) {\n  return (\n    <SavedLists>\n      {wordLists.map((wordList, idx) => {\n        return (\n          <SavedListItem\n            key={idx}\n            onClick={() => {\n              if (selected !== idx) {\n                select(idx);\n              }\n            }}\n            selected={selected === idx}\n          >\n            Crossword #{idx} ({wordList.length} word\n            {wordList.length === 1 ? '' : 's'})\n            {selected === idx && (\n              <>\n                <TextButton\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    let url = new URL(window.location.href);\n                    url.hash = `#${btoa(JSON.stringify(wordList))}`;\n                    navigator.clipboard.writeText(url);\n                  }}\n                >\n                  (Copy URL)\n                </TextButton>\n                <TextButton\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    remove(idx);\n                  }}\n                >\n                  (Delete)\n                </TextButton>\n                <TextButton\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    duplicate(idx);\n                  }}\n                >\n                  (Duplicate)\n                </TextButton>\n              </>\n            )}\n          </SavedListItem>\n        );\n      })}\n      {children}\n    </SavedLists>\n  );\n}\n\nfunction EditorToolbar({\n  inputRef,\n  gridSize,\n  draftWord,\n  setDraftWord,\n  draftDirection,\n  setDraftDirection,\n  currentlySaved,\n  saveWordList,\n}) {\n  let validateWordInput = (e) => {\n    e.target.value = e.target.value.replace(/[^\\w]/g, '').toUpperCase();\n    setDraftWord(e.target.value);\n  };\n\n  return (\n    <Toolbar>\n      <ToolbarSection>\n        <WordInputWrapper>\n          <WordInput\n            value={draftWord}\n            onChange={(e) => validateWordInput(e)}\n            placeholder={'Enter a new word...'}\n            ref={inputRef}\n          />\n          <WordInputCounter\n            error={draftWord.length > gridSize}\n            empty={draftWord.length === 0}\n          >\n            {draftWord.length}\n          </WordInputCounter>\n        </WordInputWrapper>\n        <Hint>\n          <HintText>Clear with Escape</HintText>\n          <Key>ESC</Key>\n        </Hint>\n      </ToolbarSection>\n      <DraftDirectionButtons\n        setDraftDirection={setDraftDirection}\n        draftDirection={draftDirection}\n      />\n      <Buttons minWidth={'100px'}>\n        <Button\n          onClick={saveWordList}\n          fullWidth={true}\n          unclickable={currentlySaved}\n        >\n          Save\n        </Button>\n        <Hint>\n          <HintText>{currentlySaved ? '✔ Saved' : '✖ Unsaved'}</HintText>\n        </Hint>\n      </Buttons>\n    </Toolbar>\n  );\n}\n\nfunction EditableCrosswordGrid({\n  draftWord,\n  draftDirection,\n  removeWord,\n  commitWord,\n  grid,\n}) {\n  let [candidatePosition, setCandidatePosition] = useState(null);\n\n  // Is there a word starting here? (Preferably, one in the right direction.)\n  let wordHere = null;\n  if (candidatePosition) {\n    let { x, y } = candidatePosition;\n    let wordHereAcross = grid[y][x].wordHereAcross;\n    let wordHereDown = grid[y][x].wordHereDown;\n    wordHere =\n      draftDirection === 'x'\n        ? wordHereAcross ?? wordHereDown\n        : wordHereDown ?? wordHereAcross;\n  }\n\n  let modifiableWordItem, canCommitDraftWord;\n  if (draftWord) {\n    // Making a new word. We can't commit if there's already a word here in the\n    // same direction.\n    modifiableWordItem = null;\n    canCommitDraftWord = !wordHere || wordHere.direction !== draftDirection;\n  } else {\n    // If we're hovering over a word, we can edit it.\n    modifiableWordItem = wordHere;\n    canCommitDraftWord = false;\n  }\n\n  let handleMouseEnter = (x, y) => {\n    setCandidatePosition({ x, y });\n  };\n  let handleMouseLeave = () => {\n    setCandidatePosition(null);\n  };\n  return (\n    <Grid>\n      {grid.map((row, y) => {\n        return (\n          <GridRow key={y}>\n            {row.map((cell, x) => {\n              let { chars, allWordsHere } = cell;\n\n              function getCharFromWord({ word, direction, x: wx, y: wy }) {\n                let chars = [...word];\n                if (direction === 'x' && wy === y) {\n                  return chars[x - wx];\n                } else if (direction === 'y' && wx === x) {\n                  return chars[y - wy];\n                }\n              }\n\n              let modifiableIsHere = false;\n              let draftChar = '';\n              if (allWordsHere.has(modifiableWordItem)) {\n                modifiableIsHere = true;\n                draftChar = getCharFromWord(modifiableWordItem);\n              }\n              if (candidatePosition) {\n                draftChar =\n                  getCharFromWord({\n                    word: draftWord,\n                    direction: draftDirection,\n                    x: candidatePosition.x,\n                    y: candidatePosition.y,\n                  }) || '';\n              }\n\n              return (\n                <GridCell\n                  key={x}\n                  onMouseEnter={() => handleMouseEnter(x, y)}\n                  onMouseLeave={() => handleMouseLeave(x, y)}\n                  interactable={canCommitDraftWord || modifiableIsHere}\n                  placeable={draftWord.length > 0 && canCommitDraftWord}\n                  holdingWord={draftWord.length > 0}\n                  modifiable={modifiableIsHere}\n                  hover={modifiableIsHere && !draftWord.length}\n                  hasLetter={chars.size || draftChar}\n                  onClick={() => {\n                    if (modifiableWordItem) {\n                      removeWord(modifiableWordItem);\n                    } else if (canCommitDraftWord) {\n                      commitWord(x, y);\n                    }\n                  }}\n                >\n                  <GridCellContents>\n                    <GridCellNumber>{grid[y][x].cellNumber}</GridCellNumber>\n                    {uniq([...sortBy([...chars]), ...draftChar]).map((c) => {\n                      return (\n                        <GridCellChar\n                          error={\n                            chars.size > 1 ||\n                            (chars.size > 0 &&\n                              c === draftChar &&\n                              !chars.has(draftChar))\n                          }\n                          draft={c === draftChar}\n                          key={c}\n                        >\n                          {c}\n                        </GridCellChar>\n                      );\n                    })}\n                  </GridCellContents>\n                </GridCell>\n              );\n            })}\n          </GridRow>\n        );\n      })}\n    </Grid>\n  );\n}\n\nfunction PlayableCrosswordGrid({ draftDirection, grid }) {\n  let gridRef = useRef(null);\n\n  let handleMouseEnter = (x, y) => {\n    //\n  };\n  let handleMouseLeave = () => {\n    //\n  };\n\n  function handleChange(e, x, y) {\n    const input = e.target;\n    const { value, selectionStart } = input;\n\n    // TODO: better unicode support\n    let char = value.charAt(selectionStart - 1);\n    if (/[\\w]/.test(char)) {\n      e.target.value = char.toUpperCase();\n\n      // Get the next input field\n      let thisCell = grid[y][x];\n      let nextCell =\n        draftDirection === 'x'\n          ? thisCell.nextCellAcross\n          : thisCell.nextCellDown;\n      let nextSibling = gridRef.current.querySelector(\n        `[name=\"cellinput-${nextCell.x}-${nextCell.y}\"]`\n      );\n\n      // If found, focus the next field\n      if (nextSibling !== null) {\n        nextSibling.focus();\n        nextSibling.selectionStart = nextSibling.selectionEnd = 0;\n      }\n    } else {\n      e.target.value = '';\n    }\n  }\n\n  function handleKeyDown(e, x, y) {\n    if (e.key === 'Backspace') {\n      handleBackspace(e, x, y);\n    }\n    if (e.key === 'ArrowLeft') {\n      moveOneCell(x, y, 'x', true);\n    }\n    if (e.key === 'ArrowRight') {\n      moveOneCell(x, y, 'x', false);\n    }\n    if (e.key === 'ArrowUp') {\n      moveOneCell(x, y, 'y', true);\n    }\n    if (e.key === 'ArrowDown') {\n      moveOneCell(x, y, 'y', false);\n    }\n  }\n\n  function moveOneCell(x, y, dir, backwards) {\n    let thisCell = grid[y][x];\n    let targetCell = null;\n\n    if (backwards) {\n      targetCell =\n        dir === 'x'\n          ? thisCell.previousCellAcross\n          : thisCell.previousCellDown;\n    } else {\n      targetCell =\n        dir === 'x'\n          ? thisCell.nextCellAcross\n          : thisCell.nextCellDown;\n    }\n    let targetSibling = gridRef.current.querySelector(\n      `[name=\"cellinput-${targetCell.x}-${targetCell.y}\"]`\n    );\n\n    if (targetSibling !== null) {\n      targetSibling.focus();\n    }\n    return targetSibling;\n  }\n\n  function handleBackspace(e, x, y) {\n    const { value } = e.target;\n    if (value.length !== 0) {\n      // Allow normal backspace\n      e.target.value = '';\n      return;\n    }\n\n    e.preventDefault();\n\n    let prevSibling = moveOneCell(x, y, draftDirection, true);\n    if (prevSibling) {\n      prevSibling.value = prevSibling.value.slice(0, -1);\n    }\n  }\n\n  return (\n    <Grid ref={gridRef}>\n      {grid.map((row, y) => (\n        <GridRow key={y}>\n          {row.map((cell, x) => {\n            let hasLetter = cell.chars.size > 0;\n            return (\n              <GridCell\n                key={x}\n                onMouseEnter={() => handleMouseEnter(x, y)}\n                onMouseLeave={() => handleMouseLeave(x, y)}\n                hasLetter={hasLetter}\n              >\n                <GridCellContents>\n                  <GridCellNumber>{grid[y][x].cellNumber}</GridCellNumber>\n                  {hasLetter > 0 && (\n                    <GridCellInput\n                      name={`cellinput-${x}-${y}`}\n                      onChange={(e) => handleChange(e, x, y)}\n                      onKeyDown={(e) => handleKeyDown(e, x, y)}\n                    />\n                  )}\n                </GridCellContents>\n              </GridCell>\n            );\n          })}\n        </GridRow>\n      ))}\n    </Grid>\n  );\n}\n\nfunction useLocalStorageState(key, defaultValue) {\n  let [value, setValue] = useState(() => {\n    const saved = localStorage.getItem(key);\n    const initialValue = JSON.parse(saved);\n    return initialValue || defaultValue;\n  });\n  useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value));\n  }, [key, value]);\n  return [value, setValue];\n}\n\nfunction EditorApp() {\n  let inputRef = useRef(null);\n\n  let [currentlySaved, setCurrentlySaved] = useState(true);\n\n  let [draftDirection, setDraftDirection] = useState('x');\n  let [draftWord, setDraftWord] = useState('');\n  let [draftClue, setDraftClue] = useState('');\n\n  let [wordList, setWordList] = useLocalStorageState('wordList', []);\n\n  // TODO: change wordlists to an object where the keys are unique timestamps etc,\n  // instead of using an array, so you can have titles for each crossword and links\n  // to them, etc\n  let [currentWordListIdx, setCurrentWordListIdx] = useLocalStorageState(\n    'currentWordListIdx',\n    0\n  );\n  let [savedWordLists, setSavedWordLists] = useLocalStorageState(\n    'savedWordLists',\n    []\n  );\n\n  usePreventWindowUnload(!currentlySaved);\n\n  let saveWordList = () => {\n    setCurrentlySaved(true);\n    setSavedWordLists((prevSavedWordLists) => {\n      if (prevSavedWordLists[currentWordListIdx]) {\n        return prevSavedWordLists.map((prevList, idx) => {\n          return idx === currentWordListIdx ? wordList : prevList;\n        });\n      } else {\n        return [...prevSavedWordLists, []];\n      }\n    });\n  };\n\n  useEffect(() => {\n    let swapDraftDirection = () => {\n      setDraftDirection(draftDirection === 'x' ? 'y' : 'x');\n    };\n    function handleKeyDown(e) {\n      if (e.code === 'Enter') {\n        e.preventDefault();\n        swapDraftDirection();\n      }\n      if (e.code === 'Escape') {\n        e.preventDefault();\n        setDraftWord('');\n      }\n    }\n    document.body.addEventListener('keydown', handleKeyDown);\n    return () => document.body.removeEventListener('keydown', handleKeyDown);\n  }, [draftDirection]);\n\n  useEffect(() => {\n    if (!savedWordLists[currentWordListIdx]) {\n      setCurrentlySaved(true);\n      setSavedWordLists((prevSavedWordLists) => {\n        return [...prevSavedWordLists, []];\n      });\n      setWordList([]);\n    } else {\n      setWordList(savedWordLists[currentWordListIdx]);\n    }\n  }, [savedWordLists, currentWordListIdx, setWordList, setSavedWordLists]);\n\n  let updateClue = (wordItem, clue) => {\n    updateWordList((prevWordList) => {\n      return sortBy(\n        prevWordList.map((item) =>\n          item.word === wordItem.word &&\n          item.x === wordItem.x &&\n          item.y === wordItem.y\n            ? { ...item, clue }\n            : item\n        ),\n        (item) => item.y,\n        (item) => item.x\n      );\n    });\n  };\n\n  let addWord = (x, y, direction, word, clue) => {\n    updateWordList((prevWordList) => {\n      return sortBy(\n        [...prevWordList, { x, y, direction, word, clue }],\n        (item) => item.y,\n        (item) => item.x\n      );\n    });\n  };\n\n  let newWordList = () => {\n    selectWordList(savedWordLists.length);\n  };\n\n  let selectWordList = (listIdx) => {\n    if (!currentlySaved) {\n      alert('You have unsaved changes');\n    } else {\n      setCurrentWordListIdx(listIdx);\n    }\n  };\n\n  let removeWordList = (idx) => {\n    if (currentWordListIdx === idx) {\n      // Remove the current wordlist\n      setCurrentWordListIdx(0);\n      setSavedWordLists((prevWordLists) => {\n        return [\n          ...prevWordLists.slice(0, idx),\n          ...prevWordLists.slice(idx + 1),\n        ];\n      });\n    } else {\n      if (!currentlySaved) {\n        alert('Please save before making changes');\n      }\n      // BUG: removing other wordlists will erase your unsaved data\n    }\n  };\n\n  let duplicateWordList = (idx) => {\n    if (currentWordListIdx === idx) {\n      // Remove the current wordlist\n      setCurrentWordListIdx(0);\n      setSavedWordLists((prevWordLists) => {\n        return [\n          ...prevWordLists.slice(0, idx),\n          ...prevWordLists.slice(idx, idx + 1),\n          ...prevWordLists.slice(idx),\n        ];\n      });\n    } else {\n      if (!currentlySaved) {\n        alert('Please save before making changes');\n      }\n      \n    }\n  };\n\n  let updateWordList = (func) => {\n    setCurrentlySaved(false);\n    setWordList(func);\n  };\n\n  let gridSize = 15;\n  let grid = useMemo(\n    () => buildGridFromWordList(wordList, gridSize),\n    [wordList, gridSize]\n  );\n\n  let commitWord = (x, y) => {\n    addWord(x, y, draftDirection, draftWord, draftClue);\n    setDraftWord('');\n    setDraftClue('');\n    inputRef.current.focus();\n  };\n  let removeWord = (wordItem) => {\n    updateWordList(wordList.filter((item) => item !== wordItem));\n    setDraftWord(wordItem.word);\n    setDraftClue(wordItem.clue);\n    setDraftDirection(wordItem.direction);\n  };\n\n  return (\n    <Body>\n      <EditorToolbar\n        inputRef={inputRef}\n        gridSize={gridSize}\n        draftWord={draftWord}\n        setDraftWord={setDraftWord}\n        draftDirection={draftDirection}\n        setDraftDirection={setDraftDirection}\n        currentlySaved={currentlySaved}\n        saveWordList={saveWordList}\n      />\n      <GridClueContainer>\n        <EditableCrosswordGrid\n          draftWord={draftWord}\n          draftDirection={draftDirection}\n          removeWord={removeWord}\n          commitWord={commitWord}\n          grid={grid}\n        />\n        <ClueList\n          wordList={wordList}\n          grid={grid}\n          updateClue={updateClue}\n          editable={true}\n        />\n      </GridClueContainer>\n      <SavedWordLists\n        wordLists={savedWordLists}\n        selected={currentWordListIdx}\n        saved={currentlySaved}\n        select={selectWordList}\n        remove={removeWordList}\n        duplicate={duplicateWordList}\n      >\n        <Button onClick={newWordList}>New Crossword</Button>\n      </SavedWordLists>\n    </Body>\n  );\n}\n\nfunction PlayerApp({ wordList, gridSize }) {\n  let [draftDirection, setDraftDirection] = useState('x');\n  let grid = useMemo(\n    () => buildGridFromWordList(wordList, gridSize),\n    [wordList, gridSize]\n  );\n\n  return (\n    <Body>\n      <Toolbar>\n        <DraftDirectionButtons\n          setDraftDirection={setDraftDirection}\n          draftDirection={draftDirection}\n        />\n      </Toolbar>\n      <GridClueContainer>\n        <PlayableCrosswordGrid draftDirection={draftDirection} grid={grid} />\n        <ClueList wordList={wordList} grid={grid} editable={false} />\n      </GridClueContainer>\n    </Body>\n  );\n}\n\nfunction useLocationHash() {\n  let [hash, setHash] = useState(window.location.hash);\n  useEffect(() => {\n    function handleHashChange() {\n      setHash(window.location.hash);\n    }\n    window.addEventListener('hashchange', handleHashChange);\n    return () => {\n      window.removeEventListener('hashchange', handleHashChange);\n    };\n  }, []);\n  return hash;\n}\n\nfunction App() {\n  let hash = useLocationHash();\n\n  if (hash) {\n    const wordList = JSON.parse(atob(hash.slice(1)));\n    let gridSize = 15;\n    return <PlayerApp wordList={wordList} gridSize={gridSize} />;\n  } else {\n    return <EditorApp />;\n  }\n}\n\nlet Body = styled.div`\n  font-size: 16px;\n`;\n\nlet Toolbar = styled.div`\n  display: flex;\n  padding: 5px;\n`;\nlet ToolbarSection = styled.div`\n  display: flex;\n  flex-direction: column;\n  text-align: center;\n  flex-grow: 1;\n`;\nlet WordInputWrapper = styled.div`\n  display: flex;\n  flex-direction: row;\n  align-items: stretch;\n`;\nlet wordInputRadius = '3px';\nlet WordInputCounter = styled.div`\n  font-weight: bold;\n  padding: 4px;\n  width: 2em;\n  background: #eee;\n  border: 1px solid #999;\n  border-radius: 0 ${wordInputRadius} ${wordInputRadius} 0;\n  border-left: none;\n  color: ${(props) => (props.error ? 'red' : props.empty ? '#ddd' : '#555')};\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`;\nlet WordInput = styled.input`\n  flex-grow: 1;\n  padding: 6px 7px;\n  letter-spacing: 3px;\n  border-radius: ${wordInputRadius} 0 0 ${wordInputRadius};\n  border: 1px solid #999;\n  z-index: 2;\n  ::placeholder,\n  ::-webkit-input-placeholder {\n    color: #ccc;\n    letter-spacing: initial;\n  }\n  :focus {\n    border: 1px solid #1a8fbf;\n    box-shadow: 0 0 1px 2px #1a8fbf;\n    outline: none;\n  }\n`;\n\nlet Buttons = styled.div`\n  text-align: center;\n  margin-left: 10px;\n  min-width: ${(props) => props.minWidth || 'none'};\n`;\nlet Rotate = styled.span`\n  transform: rotate(90deg);\n  display: inline-block;\n`;\nlet Button = styled.button`\n  background: ${(props) =>\n    props.selected ? '#4cc7f9' : props.unclickable ? '#ccc' : '#eee'};\n  color: ${(props) =>\n    props.selected ? 'black' : props.unclickable ? '#888' : 'black'};\n  border: 1px solid ${(props) => (props.selected ? '#1a8fbf' : '#ccc')};\n  width: ${(props) => (props.fullWidth ? '100%' : 'inherit')};\n  border-radius: ${(props) =>\n    props.rightMost\n      ? '0 10px 10px 0'\n      : props.leftMost\n      ? '10px 0 0 10px'\n      : '10px'};\n  padding: 7px;\n  cursor: ${(props) => (props.unclickable ? 'default' : 'pointer')};\n  :hover {\n    background: ${(props) =>\n      props.selected ? '#4cc7f9' : props.unclickable ? '#ccc' : '#ddd'};\n  }\n`;\n\nlet Hint = styled.div`\n  font-color: #999;\n  padding: 5px;\n  font-size: 0.5em;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`;\nlet HintText = styled.span`\n  margin-right: 5px;\n`;\nlet Key = styled.span`\n  font-color: #999;\n  padding: 3px 5px 10px ${(props) => (props.val === 'enter' ? '10px' : '5px')};\n  display: inline-block;\n  background: #eee;\n\n  height: 0.5em;\n  border: 1px solid #999;\n  font-size: 1em;\n  border-radius: 3px;\n  vertical-align: middle;\n`;\n\nlet GridClueContainer = styled.div`\n  display: flex;\n  align-items: stretch;\n`;\n\nlet Grid = styled.div`\n  display: flex;\n  flex-direction: column;\n  gap: 1px;\n  background: #7b7a87;\n  border: 1px solid #7b7a87;\n`;\n\nlet GridRow = styled.div`\n  display: flex;\n  flex-direction: row;\n  gap: 1px;\n`;\n\nlet GridCell = styled.div`\n  cursor: ${(props) =>\n    props.holdingWord && !props.placeable\n      ? 'not-allowed'\n      : props.holdingWord\n      ? 'grabbing'\n      : props.interactable\n      ? 'grab'\n      : 'default'};\n  background: ${(props) =>\n    props.modifiable && props.hover\n      ? '#eee'\n      : props.hasLetter\n      ? '#fff'\n      : 'black'};\n`;\n\nlet GridCellContents = styled.div`\n  width: 1.5em;\n  height: 1.5em;\n  text-align: center;\n  position: relative;\n  display: flex;\n  align-items: center;\n  box-sizing: border-box;\n  justify-content: center;\n  text-transform: uppercase;\n`;\n\nlet GridCellChar = styled.div`\n  color: ${(props) => (props.error ? 'red' : null)};\n  font-weight: ${(props) => (props.draft ? 'bold' : '')};\n  padding-top: 0.4em;\n  width: 100%;\n  box-sizing: border-box;\n`;\nlet GridCellInput = styled.input`\n  width: 100%;\n  position: absolute;\n  background: transparent;\n  text-align: center;\n  box-sizing: border-box;\n  top: 0;\n  left: 0;\n  border: 0px;\n  font-size: 1em;\n  padding: 0;\n  padding-top: 0.4em;\n  caret-color: transparent;\n\n  :focus {\n    border: 0px;\n    box-shadow: 0 0 1px 1px #1a8fbf;\n    outline: none;\n    background: #4cc7f9;\n  }\n`;\n\nlet GridCellNumber = styled.span`\n  position: absolute;\n  top: 0px;\n  left: 1px;\n  font-size: 0.5em;\n  z-index: 2;\n`;\n\nlet SavedLists = styled.div`\n  padding: 10px;\n`;\nlet SavedListItem = styled.div`\n  padding: 10px;\n  background: ${(props) => (props.selected ? '#4cc7f9' : '#eee')};\n  color: ${(props) => (props.selected ? 'black' : 'black')};\n  border: 1px solid ${(props) => (props.selected ? '#1a8fbf' : '#eee')};\n  cursor: ${(props) => (props.selected ? 'default' : 'pointer')};\n  :hover {\n    background: ${(props) => (props.selected ? '#4cc7f9' : '#ddd')};\n  }\n`;\nlet TextButton = styled.button`\n  background: none;\n  border: none;\n  color: #1a8fbf;\n  text-decoration: underline;\n  cursor: pointer;\n  padding: 0px 10px;\n  :hover {\n    color: #fff;\n  }\n`;\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}